import sys
sys.path.insert(0,'/scratch/nsm36/ViennaRNA/lib/python2.7/site-packages') #for ViennaRNA in TCM
import RNA
import numpy as np
from rna_structural_functions import dotbracket_to_coarsegrained_lev1, lev1_or_2_to_lev5, lev1_to_lev2, dotbracket_to_coarsegrained_for_level



index_to_base = {0: 'A', 1: 'C', 2: 'U', 3: 'G'}
base_to_number={'A':0, 'C':1, 'U':2, 'G':3, 'T':2}

RNA.cvar.uniq_ML = 1 # global switch for unique multiloop decomposition
kbT = RNA.exp_param().kT/1000.0
db_to_shape_lev1, cg1_to_cg2, cg1_to_cg5 = {}, {}, {}


   
############################################################################################################
## get shape and prob
############################################################################################################

def add_shape_prob_lev1(structure, energy, data):
   """ function needed for subopt from ViennaRNA documentation: https://www.tbi.univie.ac.at/RNA/ViennaRNA/doc/RNAlib-2.4.14.pdf"""
   if not structure == None:
      if len(structure) < 40:
         try:
            shape = db_to_shape_lev1[structure]
         except KeyError:
            shape = dotbracket_to_coarsegrained_lev1(structure)
            db_to_shape_lev1[structure] = shape
      else:
         shape = dotbracket_to_coarsegrained_lev1(structure)
      try:
         data[shape] += np.exp(-1*energy/kbT)
      except KeyError:
         data[shape] = np.exp(-1*energy/kbT)


def convert_Boltzmannensemble(function, dict_Boltzmann, dict_to_save):
   dict_Boltzmann_conv = {}
   if dict_to_save:
      for shape, prob in dict_Boltzmann.iteritems():
         try:
            shape_cov = dict_to_save[shape]
         except KeyError:
            shape_cov = function(shape)
            dict_to_save[shape] = shape_cov
         try:
            dict_Boltzmann_conv[shape_cov] += prob
         except KeyError:
            dict_Boltzmann_conv[shape_cov] = prob    
   else:
      for shape, prob in dict_Boltzmann.iteritems():
         try:
            dict_Boltzmann_conv[function(shape)] += prob
         except KeyError:
            dict_Boltzmann_conv[function(shape)] = prob  
   return dict_Boltzmann_conv


def get_shapes_prob_subopt(sequence_str, shape_level = 2, range_kbT=15, allow_isolated_bps=False, dangling_ends_option=2):
   """ for the sequence sequence_str find the Boltzmann ensemble of shapes of the given shape level (1, 2 or 5) as a dictionary;
   the output will be computed based on the structures within a free energy of range_kbT*kbT of the mfe structure;
   subopt code adapted from ViennaRNA documentation: https://www.tbi.univie.ac.at/RNA/ViennaRNA/doc/RNAlib-2.4.14.pdf"""
   RNA.cvar.uniq_ML = 1
   md = RNA.md()
   if not allow_isolated_bps:
      md.noLP = 1 #no isolated base pairs
   md.dangles = dangling_ends_option #use dangling ends -d1
   a = RNA.fold_compound(sequence_str, md)
   G_range_kcal = range_kbT * kbT 
   shapelev1_vs_Boltzmannsum = {}
   a.subopt_cb(int(G_range_kcal*100), add_shape_prob_lev1, shapelev1_vs_Boltzmannsum)
   Z_eff = sum(shapelev1_vs_Boltzmannsum.values())
   if shape_level == 1:
      shape_vs_Boltzmannsum = shapelev1_vs_Boltzmannsum 
   elif shape_level == 2:
      if len(sequence_str) > 60:
          shape_vs_Boltzmannsum = convert_Boltzmannensemble(lev1_to_lev2, shapelev1_vs_Boltzmannsum, None)
      else:
          shape_vs_Boltzmannsum = convert_Boltzmannensemble(lev1_to_lev2, shapelev1_vs_Boltzmannsum, cg1_to_cg2)
   elif shape_level == 5:
      if len(sequence_str) > 60:
          shape_vs_Boltzmannsum = convert_Boltzmannensemble(lev1_to_lev5, shapelev1_vs_Boltzmannsum, None)
      else:
          shape_vs_Boltzmannsum = convert_Boltzmannensemble(lev1_to_lev5, shapelev1_vs_Boltzmannsum, cg1_to_cg5)
   else:
      raise ValueError('shape level not implemented: ' + str(shape_level))
   return {s: B/Z_eff for s, B in shape_vs_Boltzmannsum.iteritems()}

############################################################################################################
## most frequent shape
############################################################################################################


def find_most_freq_shape(sequence_str, shape_level, range_kbT, folding_criterion, dangling_ends_option, allow_isolated_bps=False):
   return find_most_freq_shape_and_prob(sequence_str, shape_level, range_kbT, folding_criterion, dangling_ends_option, allow_isolated_bps)[0]


def find_most_freq_shape_and_prob(sequence_str, shape_level, range_kbT, folding_criterion, dangling_ends_option, allow_isolated_bps=False):
   output_dict = get_shapes_prob_subopt(sequence_str, shape_level=shape_level, range_kbT=range_kbT, 
                                       allow_isolated_bps=allow_isolated_bps, dangling_ends_option=dangling_ends_option)
   s = max(output_dict.keys(), key=output_dict.get)
   if len(output_dict.values()) > 1:
      pmax, pmax2 = sorted([v for v in output_dict.values()], reverse=True)[:2]
      if pmax/pmax2 >= folding_criterion:
         return s, output_dict[s]
      else:
         return '|', np.nan
   else:
      return s, output_dict[s]
   
############################################################################################################
##find shrep
############################################################################################################
def find_shrep_subopt(structure, energy, data):
   """ function needed for subopt from ViennaRNA documentation: https://www.tbi.univie.ac.at/RNA/ViennaRNA/doc/RNAlib-2.4.14.pdf"""
   if not structure == None and (data['shrep'] == '' or energy < data['shrep G']):
      shape_subopt = dotbracket_to_coarsegrained_for_level(structure, shape_level=data['shape_level'])
      if data['shape'] == shape_subopt:
         assert data['shrep'] == '' or energy < data['shrep G']
         data['shrep'] = structure
         data['shrep G'] = energy

def get_shrep(sequence_str, shape, shape_level=2, range_kbT=15, allow_isolated_bps=False, dangling_ends_option=1):
   """ for the sequence sequence_str, calculate the lowest free-energy structure within a shape;
   subopt code adapted from ViennaRNA documentation: https://www.tbi.univie.ac.at/RNA/ViennaRNA/doc/RNAlib-2.4.14.pdf"""
   RNA.cvar.uniq_ML = 1
   md = RNA.md()
   if not allow_isolated_bps:
      md.noLP = 1 #no isolated base pairs
   md.dangles = dangling_ends_option #use dangling ends -d1
   a = RNA.fold_compound(sequence_str, md)
   G_range_kcal = range_kbT * kbT 
   data = {'shape': shape, 'shape_level': shape_level, 'shrep': '', 'shrep G': 10}
   a.subopt_cb(int(G_range_kcal*100), find_shrep_subopt, data)
   assert data['shrep']
   return data['shrep']

############################################################################################################
## test against manual usage of bioconda package
############################################################################################################
if __name__ == "__main__":
   #test data generated with bioconda installation of RNAshapes
   testsequence = 'AAUUUAGUAGGUAGUGUAAGAUAAGCGAUGGCAGACGCUGUUUAAUUACGACCGACUCUGAGUCUGCCGC'
   shape_prob_dict_bioconda = {'[[[[_[]_]_]_][]]': 0.000921, '[[_[_[_[_[]_]_]_]_]_]': 0.00965, '[_[_[_[]_]_]]': 0.0058889, '[_[_[_[]_]_]_]': 0.0997203, '[_[[_[_[]_]_][]]]': 0.0007249, '[_[]_][]': 0.0012272, '[[_[_[_[]_]_]_]_]': 0.0041262, '[[_[_[_[]_]_]_][]]': 0.0021908, 
                               '[_[_[_[_[_[]_]_]]_]_]': 0.0009226, '[_[_[_[]]_]_]': 0.0035857, '[_[_[[_[]_]_]_]_]': 0.0214693, '[_[_[_[_[_[]]_]]_]_]': 0.0010355, '[_[_[_[_[]_]_]]_]': 0.0460973, 
                               '[][]': 0.0048308, '[_[_[_[_[]_]_]_]_]': 0.2351865, '[_[_[_[[]_]_]_]_]': 0.0005859, '[_[_[[_[]_]_]_]]': 0.0110389, '[[_[_[_[_[]]_]_]_]_]': 0.0057199, '[_[_[_[_[_[]]_]_]_]_]': 0.0022602, 
                               '[_[[_[]_]_]_][]': 0.0021883, '[_[]_]': 0.0178198, '[[_[_[_[_[]]_]]_]_]': 0.0020319, '[_[_[[_[]_]_]]_]': 0.0328402, '[_[_[]_]_][]': 0.010432, '[_[[_[_[]]_][]]]': 0.0007165, '[_[_[[[_[]_]_]_]_]]': 0.0052065, '[[[_[_[]_]_]_][]]': 0.0013016, 
                               '[_[_[_[_[_[]_]_]_]_]_]': 0.0036664, '[_[_[]_]]': 0.0019681, '[_[[_[]]_]_]': 0.0009536, '[_[_[]_]][]': 0.0038539, '[[_[_[]_]_]_]': 0.0013819, '[_[[[_[]_]_][]]]': 0.0006072, '[[_[]_][]]': 0.0032573, 
                               '[[_[_[_[_[]_]_]]_]_]': 0.0019066, '[_[_[[_[_[]]_]_]_]]': 0.0078202, '[_[_[[_[_[]_]_]_]_]_]': 0.0035638, '[[[_[]_]_]_]': 0.0009261, '[_[_[_[_[_[]]]_]_]_]': 0.0005228, '[_[_[_[]_]_]][]': 0.0048162, '[_[_[_[_[]]_]_]]': 0.0078223, '[_[_[[[_[]]_]_]_]]': 0.002304, '[_[[_[]]_]_][]': 0.0007483, '[]': 0.0085709, 
                               '[[_[]_][[]_]]': 0.0006801, '[[_[_[[_[]]_]]_]_]': 0.0006004, '[[_[_[]]_]_]': 0.0013412, '[_[[_[]]_]][]': 0.0015154, 
                               '[[_[_[[_[_[]]_]_]_]_]_]': 0.0010687, '[_[_[_[_[]_]_]_]]': 0.0075146, '[_[]]': 0.0009957, '[_[_[_[[]_]_]]_]': 0.0010736, '[[[_[]]_][]]': 0.0011623, '[_[_[[_[]]_]]_]': 0.014512, '[[[_[_[]]_]_][]]': 0.0014602, '[[_[_[]_]_][[]_]]': 0.0009515, '[_[_[[_[]]_]_]_]': 0.0072603, '[[_[_[]]_][[]_]]': 0.000902, '[[_[_[_[]]_]_][]]': 0.0013118, 
                               '[[_[_[[_[]_]_]_]_]_]': 0.0008666, '[_[_[_[_[]]_]]_]': 0.0491059, '[[_[]_]_]': 0.0010412, '[_[[_[]_][]]]': 0.0005394, '[_[]_][_[]_]': 0.0019472, '[[_[_[]_]_][]]': 0.0052668, '[[[_[]_]_][]]': 0.0036425, '[_[[_[]_]_]_]': 0.0025148, '[_[_[_[_[]]_]_]_]': 0.1386877, 
                               '[_[_[]]_][]': 0.0007818, '[_[_[[_[_[]_]_]_]_]]': 0.0073101, '[_[_[_[]]_]][]': 0.0051353, '[_[_[]_]_]': 0.0033879, '[_[_[_[]]_]_][]': 0.0147274, 
                               '[_[[_[]_]_]][]': 0.0034288, '[][_[]_]': 0.0100306, '[_[[][]]_]': 0.0010107, '[_[_[_[[_[]_]_]]_]_]': 0.0006704, '[[_[_[_[]_]]_]_]': 0.0014827, '[_[_[_[_[]_]]_]_]': 0.0007359, '[[_[_[[_[]_]_]]_]_]': 0.0013585, '[_[_[[_[_[]]_]_]_]_]': 0.0262553, 
                               '[_[_[_[]_]_]_][]': 0.0245616, '[_[[_[_[]]_]_]_][]': 0.0026988, '[[_[_[]]_][]]': 0.0043865, '[_[_[_[]_]]_]': 0.0357878, '[_[_[[_[]]_]_]]': 0.0023566, '[_[_[[_[_[]]]_]_]_]': 0.0017723}
   shrep_dict_bioconda = {'[[[[_[]_]_]_][]]': '.........((((((((((((..((((........))))..))..)))).)).((((...))))))))..', '[[_[_[_[_[]_]_]_]_]_]': '.(((((((.(((.(((...((..((((........))))..))...))).))).)))..)))).......', 
                                 '[_[_[_[]_]_]]': '.((((((.((....(((((....((((........))))......))))).....)))))))).......', '[_[_[_[]_]_]_]': '.((((((..(((.(((.......((((........)))).......))).)))....)))))).......', 
                                 '[_[[_[_[]_]_][]]]': '......((.((((.(((((..((((((.((.....)).)))))).)))))...((((...))))))))))', '[_[]_][]': '.........(((...........((((........))))...........)))((((...))))......', 
                                 '[[_[_[_[]_]_]_]_]': '.(((((((.(((.(((.......((((........)))).......))).))).)))..)))).......', '[[_[_[_[]_]_]_][]]': '......((((((.(((...((..((((........))))..))...))).)))((((...)))))))...', 
                                 '[_[_[_[_[_[]_]_]]_]_]': '..((.(((.(((..(((((..((((((.((.....)).)))))).)))))))).)))..)).........', '[_[_[_[]]_]_]': '.((((((.......(((((..(((((...(((....)))))))).))))).......)))))).......', 
                                 '[_[_[[_[]_]_]_]_]': '.((((((..(((...((((((..((((........))))..))..)))).)))....)))))).......', '[_[_[_[_[_[]]_]]_]_]': '..((.(((.(((..(((((..(((((...(((....)))))))).)))))))).)))..)).........', 
                                 '[_[_[_[_[]_]_]]_]': '.((((((..(((..(((((..((((((.((.....)).)))))).))))))))....)))))).......', '[][]': '..............(((.......)))..(((((((.........................)))))))..', 
                                 '[_[_[_[_[]_]_]_]_]': '.((((((..(((.(((...((..((((........))))..))...))).)))....)))))).......', 
                                 '[_[_[_[[]_]_]_]_]': '.((((((..(((...((((..((((((........))))...)).)))).)))....)))))).......', '[_[_[[_[]_]_]_]]': '.((((((.((...((((((....((((........))))......)))).))...)))))))).......', 
                                 '[[_[_[_[_[]]_]_]_]_]': '.(((((((.(((.(((..(((((.(((........))))))))...))).))).)))..)))).......', 
                                 '[_[_[_[_[_[]]_]_]_]_]': '..((.(((.(((.(((..(((((.(((........))))))))...))).))).)))..)).........', 
                                 '[_[[_[]_]_]_][]': '.........(((...((((((..((((........))))..))..)))).)))((((...))))......', '[_[]_]': '.............................(((((((...(((...........))).....)))))))..', 
                                 '[[_[_[_[_[]]_]]_]_]': '.(((((((.(((..(((((..(((((...(((....)))))))).)))))))).)))..)))).......', '[_[_[[_[]_]_]]_]': '.((((((..(((..(((((((..((((........))))..))..))))))))....)))))).......', '[_[_[]_]_][]': '.........(((.(((.......((((........)))).......))).)))((((...))))......', 
                                 '[_[[_[_[]]_][]]]': '......((.((((.(((((..(((((...(((....)))))))).)))))...((((...))))))))))', 
                                 '[_[_[[[_[]_]_]_]_]]': '.((((((.((...((((((((..((((........))))..))..)))).))...)))))))).......', '[[[_[_[]_]_]_][]]': '.........((((((((((..((((((.((.....)).)))))).)))).)).((((...))))))))..', 
                                 '[_[_[_[_[_[]_]_]_]_]_]': '..((.(((.(((.(((...((..((((........))))..))...))).))).)))..)).........', '[_[_[]_]]': '........................((...(((((((...(((...........))).....)))))))))', '[_[[_[]]_]_]': '.........(((((....((((((((...(((....))))))))............)))....)))))..', 
                                 '[_[_[]_]][]': '.........(((..(((((....((((........))))......))))))))((((...))))......', '[[_[_[]_]_]_]': '.........((((((((((..((((((.((.....)).)))))).))))).............)))))..', '[_[[[_[]_]_][]]]': '......((.((((.(((((((..((((........))))..))..)))))...((((...))))))))))', '[[_[]_][]]': '.........((((.(((((....((((........))))......)))))...((((...))))))))..', 
                                 '[[_[_[_[_[]_]_]]_]_]': '.(((((((.(((..(((((..((((((.((.....)).)))))).)))))))).)))..)))).......', '[_[_[[_[_[]]_]_]_]]': '.((((((.((...((((((..(((((...(((....)))))))).)))).))...)))))))).......', '[_[_[[_[_[]_]_]_]_]_]': '.((((((..(((.((((.(((..((((........)))).))).)).)).)))....)))))).......', '[[[_[]_]_]_]': '.........((((((((((((..((((........))))..))..))))).............)))))..', '[_[_[_[_[_[]]]_]_]_]': '.((((((..(((.((.((.((((.(((........)))))))))...)).)))....)))))).......', 
                                 '[_[_[_[]_]_]][]': '.........(((..(((((..((((((.((.....)).)))))).))))))))((((...))))......', '[_[_[_[_[]]_]_]]': '.((((((.((....(((((..(((((...(((....)))))))).))))).....)))))))).......', '[_[_[[[_[]]_]_]_]]': '.((((((.((...((((((((((.(((........)))))))...)))).))...)))))))).......', 
                                 '[_[[_[]]_]_][]': '.........(((...((((((((.(((........)))))))...)))).)))((((...))))......', '[]': '.............................(((((((.........................)))))))..', '[[_[]_][[]_]]': '.........((((..((((....((((........))))......))))(((((....)).)))))))..', '[[_[_[[_[]]_]]_]_]': '.(((((((.(((..(((((((((.(((........)))))))...)))))))).)))..)))).......', '[[_[_[]]_]_]': '.........((((((((((..(((((...(((....)))))))).))))).............)))))..', '[_[[_[]]_]][]': '.........(((..(((((((((.(((........)))))))...))))))))((((...))))......', 
                                 '[[_[_[[_[_[]]_]_]_]_]_]': '.(((((((.(((.((((.(((((.(((........)))))))).)).)).))).)))..)))).......', '[_[_[_[_[]_]_]_]]': '.((((((.((....(((((..((((((.((.....)).)))))).))))).....)))))))).......', '[_[]]': '........................((...(((((((.........................)))))))))', 
                                 '[_[_[_[[]_]_]]_]': '.((((((..(((..(((((..((((((........))))...)).))))))))....)))))).......', '[[[_[]]_][]]': '.........((((.(((((((((.(((........)))))))...)))))...((((...))))))))..', '[_[_[[_[]]_]]_]': '.((((((..(((..(((((((((.(((........)))))))...))))))))....)))))).......', 
                                 '[[[_[_[]]_]_][]]': '.........((((((((((..(((((...(((....)))))))).)))).)).((((...))))))))..', '[[_[_[]_]_][[]_]]': '.........((((..((((..((((((.((.....)).)))))).))))(((((....)).)))))))..', 
                                 '[_[_[[_[]]_]_]_]': '.((((((..(((...((((((((.(((........)))))))...)))).)))....)))))).......', '[[_[_[]]_][[]_]]': '.........((((..((((..(((((...(((....)))))))).))))(((((....)).)))))))..', '[[_[_[_[]]_]_][]]': '......((((((.(((..(((((.(((........))))))))...))).)))((((...)))))))...', '[[_[_[[_[]_]_]_]_]_]': '.(((((((.(((...((((((..((((........))))..))..)))).))).)))..)))).......', 
                                 '[_[_[_[_[]]_]]_]': '.((((((..(((..(((((..(((((...(((....)))))))).))))))))....)))))).......', '[[_[]_]_]': '.........((((((((((....((((........))))......))))).............)))))..', '[_[[_[]_][]]]': '......((.((((.(((((....((((........))))......)))))...((((...))))))))))', '[_[]_][_[]_]': '..........((.((.....))..))...(((((((...(((...........))).....)))))))..', '[[_[_[]_]_][]]': '.........((((.(((((..((((((.((.....)).)))))).)))))...((((...))))))))..', 
                                 '[[[_[]_]_][]]': '.........((((.(((((((..((((........))))..))..)))))...((((...))))))))..', '[_[[_[]_]_]_]': '.........(((((....((((((..((((((....))))))...)))........)))....)))))..', '[_[_[_[_[]]_]_]_]': '.((((((..(((.(((..(((((.(((........))))))))...))).)))....)))))).......', '[_[_[]]_][]': '..........(((((...(((((.(((........)))))))).)))))....((((...))))......', '[_[_[[_[_[]_]_]_]_]]': '.((((((.((...((((((..((((((.((.....)).)))))).)))).))...)))))))).......', '[_[_[_[]]_]][]': '.........(((..(((((..(((((...(((....)))))))).))))))))((((...))))......', '[_[_[]_]_]': '.((((((..(((...........((((........))))...........)))....)))))).......', 
                                 '[_[_[_[]]_]_][]': '.........(((.(((..(((((.(((........))))))))...))).)))((((...))))......', '[_[[_[]_]_]][]': '.........(((..(((((((..((((........))))..))..))))))))((((...))))......', '[][_[]_]': '..............(((.......)))..(((((((...(((...........))).....)))))))..', '[_[[][]]_]': '.........(((((....(((..((((........))))((......)).......)))....)))))..', '[_[_[_[[_[]_]_]]_]_]': '..((.(((.(((..(((((((..((((........))))..))..)))))))).)))..)).........', '[[_[_[_[]_]]_]_]': '.(((((((.(((..(((((....((((........))))......)))))))).)))..)))).......', 
                                 '[_[_[_[_[]_]]_]_]': '..((.(((.(((..(((((....((((........))))......)))))))).)))..)).........', 
                                 '[[_[_[[_[]_]_]]_]_]': '.(((((((.(((..(((((((..((((........))))..))..)))))))).)))..)))).......', '[_[_[[_[_[]]_]_]_]_]': '.((((((..(((.((((.(((((.(((........)))))))).)).)).)))....)))))).......', '[_[_[_[]_]_]_][]': '.........(((.(((...((..((((........))))..))...))).)))((((...))))......', '[_[[_[_[]]_]_]_][]': '.........(((.((((.(((((.(((........)))))))).)).)).)))((((...))))......', '[[_[_[]]_][]]': '.........((((.(((((..(((((...(((....)))))))).)))))...((((...))))))))..', '[_[_[_[]_]]_]': '.((((((..(((..(((((....((((........))))......))))))))....)))))).......', '[_[_[[_[]]_]_]]': '.((((((.((....(((((((((.(((........)))))))...))))).....)))))))).......', 
                                 '[_[_[[_[_[]]]_]_]_]': '.((((((..(((.(((((.((((.(((........)))))))))..))).)))....)))))).......'}
   shape_prob_dict_test = get_shapes_prob_subopt(testsequence, shape_level = 2, range_kbT=15, allow_isolated_bps=False, dangling_ends_option=2)
   for shape in set([s for s in shape_prob_dict_test.keys() if shape_prob_dict_test[s] > 0.01] + [s for s in shape_prob_dict_bioconda.keys()]):
      assert abs(shape_prob_dict_test[shape] - shape_prob_dict_bioconda[shape]) < 0.02
   pred_shape, pred_prob = find_most_freq_shape_and_prob(testsequence, shape_level=2, folding_criterion=1, range_kbT=15, allow_isolated_bps=False, dangling_ends_option=2)
   assert '[_[_[_[_[]_]_]_]_]' == pred_shape and abs(shape_prob_dict_bioconda['[_[_[_[_[]_]_]_]_]'] - pred_prob) < 0.02
   assert '[_[_[_[_[]_]_]_]_]' == find_most_freq_shape(testsequence, shape_level=2, folding_criterion=1, range_kbT=15, allow_isolated_bps=False, dangling_ends_option=2)
   for shape, shrep in shrep_dict_bioconda.iteritems():
      assert shape == dotbracket_to_coarsegrained_for_level(shrep, shape_level=2)     
      if not shrep == get_shrep(testsequence, shape, shape_level=2, range_kbT=15, allow_isolated_bps=False, dangling_ends_option=2):
         md = RNA.md()
         md.pf_smooth = 0 # deactivate partition function smoothing
         a = RNA.fold_compound(testsequence, md)
         G_shrep1 = a.eval_structure(shrep)
         G_shrep2 = a.eval_structure(get_shrep(testsequence, shape, shape_level=2, range_kbT=15, allow_isolated_bps=False, dangling_ends_option=2))
         if abs(G_shrep1 - G_shrep2) > 0.01: # not degenerate energy levels
            print 'different shreps, G', G_shrep1, G_shrep2
   print 'tests finished'


